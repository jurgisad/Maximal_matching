# Maximal_matching
Duotame neorentuotame grafe G, kuris turi n viršūnių ir m briaunų rasti maksimalų grafo poravimą – maksimalų briaunų E poaibį E`, tokį, kad visos briaunos neincidentinės.  
Labai plačia prasme, algoritmas kiekvieną kartą ieško suporavimo, kuris būtų viena pora didesnis nei turimas suporavimas, to neradus, paieška stabdoma ir teigiama, kad poravimas yra maksimalus. Ieškant maksimalaus poravimo negalime surasti dviejų besijungiančių dar nesuporuotų viršūnių ir pridėti jas į mūsų porų aibę, nes aklai besirenkant briaunas mes galime gauti ne optimalų sprendinį. Šis algoritmas remiasi M-augmenting kelių ieškojimu, kur kelią vadiname M-augmenting, jei jo briaunos kaitaliojasi tarp nesamų/esamų turime poravime ir prasideda bei baigiasi su nesuporuotomis viršūnėmis (iš to išplaukia, jog briaunų skaičius yra nelyginis), taip pat šis kelias turi būti paprastas – kiekviena viršūnė aplankoma tik 1 kartą. Tokį kelią radus, mes galime porų skaičiu padidinti vienetu, nes apkeičiame poravime esamas briaunas su nesamomis  
Jei suradę nesuporuotą viršūnę atliktume paieška platyn, užtikrindami, kad iš poravime nesančioje briaunos eitume į esančią, bet neužtikrintume, kad kelias bus paprastas, tai viršūnę galime aplankyti kelis kartus – pvz. joje būnant, kai einame iš suporuotos briaunos į nesuporuotą ir po to iš suporuotos į nesuporuotą arba atvirkščiai. Tokiu atveju apkeičiant briaunas mes gautume dvi šalia esančias suporuotas briaunas. Edmonds šią problemą išsprendė pristatydamas „Žiedus“ (angl. „Blossoms“).  
Žiedu mes vadinsime tokį kelią , jei jo briaunos kaitaliojasi tarp nesamų/esamų turime poravime, v0, . . . , vt−1 visos skirtingos, v0 nesuporuota su cikle esančiomis viršūnėmis, ir vt = v0. Iš to išplaukia, kad tai yra ciklas, kuris turi 2k+1 briauną, kur k - poravime esančių briaunų skaičius. Radus tokį ciklą mes jį sutraukiame ir tada rekursyviai ieškome Maugmenting kelių.  
# „Blossom“ algoritmas yra toks: 
Pradedame paieška platyn iš nesuporuotss viršūnės, jei randame, kad jo briaunas kaitaliojasi tarp nesamų/esamų turime poravime, žiūrime, ar šis kelias yra M-augmenting. Jei ne, radome žiedą ir jį sutraukiame bei tęsiame paiešką. Jei kelias yra M-augmenting, mes keičiame jo suporuotas briaunas nesuporuotomis atkeliant. reikiamus žiedus. Neradus kelio, kuris briaunas kaitaliojasi tarp nesamų/esamų turime poravime, mes teigiame, kad poravimas yra maksimalus.  
# Algoritmo sudėtingumo tyrimas: 
Teoriškai iš viso galimų iteracijų yra n/2, nes kiekvienojke iteracijoje galima pridėti vieną porą, o maksimalus porų skaičius yra n/2, taigi sudėtingumas O(n). Paprasta paieška platyn yra O(n^2), nes kiekviena viršūnė gali pasirodyti paieškoje tik po kartą, o iš jos atliekama paieška į visas likusias viršūnes. Augemnting kelią galime rasti tik kartą kiekvienoje iteracijoje, radimo laikas užtrunka O(n). Žiedų sutraukimas užtranka O(n|bc|), kur |bc| yra žiedo c ilgis, kadangi kiekvienai viršūnei/žiedui yra priskiriama maksimaliai vienas žiedas, tai bc maksimali suma = n, reiškia žiedų sutraukimas yra O(n^2). Kadangi visumoje yra O(n) iteracijų, tai viso algoritmo sudėtingumas yra O(n^3).
# Toliau tyrimas su skirtingais m ir n parametrais, kur n – viršūnių, o m – briaunų skaičius. 
Testai atlikti kievieno dydžio failui sugeneravus 10 skirtingų grafų, atliekant testą su visais jais po 10 kartų ir paimant laiką kaip vidurkį. 
Pastebėta, kad laikas kinta, keičiant m skaičių. Didinant n, bet paliekant m tokį patį veikimo greitis auga greičiau, nei kai m = n, ar m=n*1.5. Kai grafas yra pilnas, veikimo laikas su šiuo algoritmu yra ilgiausias. Iš keturių paimtų m variantų, greičiausiai algoritmas veikė su m=n*1.5. Matome, jog teorinis sudėtingumas beveik tiksliai atitinka praktinį - padidinus n 2 kartus, algoritmas veikia apie 2^3 kartų ilgiau.  
Naudoti duomenys pateikti test folderyje.

![image](https://github.com/jurgisad/Maximal_matching/assets/144427804/32208588-ff47-4652-b616-4e90e6d67de4)

